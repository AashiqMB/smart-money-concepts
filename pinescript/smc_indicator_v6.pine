//@version=6
indicator("Smart Money Concepts (Python port)", "SMC v6", overlay=true, max_labels_count=500, max_lines_count=500, max_boxes_count=300)

// === Inputs ===
swingLenInput = input.int(5, "Swing length (left/right)", minval=1)
rangePercent = input.float(1.0, "Liquidity range %", minval=0.1, step=0.1) * 0.01
showFvg = input.bool(true, "Show Fair Value Gaps")
showBOS = input.bool(true, "Show BOS/CHOCH")
showOrderBlocks = input.bool(true, "Show Order Blocks")
showLiquidity = input.bool(true, "Show Liquidity")
closeBreaks = input.bool(true, "Use close for breaks/mitigation")

// === Helper ===
f_showLabel(int b, float p, string txt, color col) =>
    label.new(b, p, txt, style=label.style_label_up, textcolor=color.white, color=col, size=size.tiny, tooltip="SMC")

// === Swings ===
var float[] swingLevels = array.new_float()
var int[] swingTypes = array.new_int()      // 1 = high, -1 = low
var int[] swingBars = array.new_int()

ph = ta.pivothigh(high, swingLenInput, swingLenInput)
pl = ta.pivotlow(low, swingLenInput, swingLenInput)
if not na(ph)
    array.push(swingLevels, ph)
    array.push(swingTypes, 1)
    array.push(swingBars, bar_index - swingLenInput)
if not na(pl)
    array.push(swingLevels, pl)
    array.push(swingTypes, -1)
    array.push(swingBars, bar_index - swingLenInput)
if array.size(swingLevels) > 300
    for _ = 0 to 49
        array.shift(swingLevels)
        array.shift(swingTypes)
        array.shift(swingBars)

// === Fair Value Gaps ===
var box[] fvgBoxes = array.new_box()
var int[] fvgDir = array.new_int()  // 1 bullish, -1 bearish
bullFvg = showFvg and bar_index > 1 and high[2] < low and close[1] > open[1]
bearFvg = showFvg and bar_index > 1 and low[2] > high and close[1] < open[1]
if bullFvg or bearFvg
    dir = bullFvg ? 1 : -1
    top = dir == 1 ? low : high[2]
    bottom = dir == 1 ? high[2] : low
    int startBar = bar_index - 1
    b = box.new(startBar, top, bar_index, bottom, bgcolor=color.new(dir == 1 ? color.teal : color.red, 70), border_color=color.new(color.white, 70), extend=extend.right)
    array.push(fvgBoxes, b)
    array.push(fvgDir, dir)

if array.size(fvgBoxes) > 0
    for i = array.size(fvgBoxes) - 1 to 0
        bx = array.get(fvgBoxes, i)
        dir = array.get(fvgDir, i)
        mitigatedBull = dir == 1 and ((closeBreaks and close < box.get_bottom(bx)) or (not closeBreaks and low < box.get_bottom(bx)))
        mitigatedBear = dir == -1 and ((closeBreaks and close > box.get_top(bx)) or (not closeBreaks and high > box.get_top(bx)))
        if mitigatedBull or mitigatedBear
            box.delete(bx)
            array.remove(fvgBoxes, i)
            array.remove(fvgDir, i)

// === BOS / CHOCH tracking ===
var int[] structureDir = array.new_int() // 1 bull, -1 bear
var string[] structureType = array.new_string() // "BOS" or "CHOCH"
var float[] structureLevel = array.new_float()
var int[] structureOriginBar = array.new_int()
var bool[] structureBroken = array.new_bool()
var int[] structureBrokenBar = array.new_int()
var line[] structureLines = array.new_line()

var int lastSwingSize = 0
if showBOS and array.size(swingLevels) != lastSwingSize
    lastSwingSize := array.size(swingLevels)
    if array.size(swingLevels) >= 4
        int sz = array.size(swingLevels)
        t1 = array.get(swingTypes, sz - 4)
        t2 = array.get(swingTypes, sz - 3)
        t3 = array.get(swingTypes, sz - 2)
        t4 = array.get(swingTypes, sz - 1)
        l1 = array.get(swingLevels, sz - 4)
        l2 = array.get(swingLevels, sz - 3)
        l3 = array.get(swingLevels, sz - 2)
        l4 = array.get(swingLevels, sz - 1)
        b1 = array.get(swingBars, sz - 2)  // event bar
        string typ = ""
        int dir = 0
        float lvl = na
        // BOS patterns
        if t1 == -1 and t2 == 1 and t3 == -1 and t4 == 1 and l1 < l3 and l3 < l2 and l2 < l4
            dir := 1
            typ := "BOS"
            lvl := l2
        if t1 == 1 and t2 == -1 and t3 == 1 and t4 == -1 and l1 > l3 and l3 > l2 and l2 > l4
            dir := -1
            typ := "BOS"
            lvl := l2
        // CHOCH patterns
        if t1 == -1 and t2 == 1 and t3 == -1 and t4 == 1 and l4 > l2 and l2 > l1 and l1 > l3
            dir := 1
            typ := "CHOCH"
            lvl := l2
        if t1 == 1 and t2 == -1 and t3 == 1 and t4 == -1 and l4 < l2 and l2 < l1 and l1 < l3
            dir := -1
            typ := "CHOCH"
            lvl := l2
        if dir != 0 and not na(lvl)
            array.push(structureDir, dir)
            array.push(structureType, typ)
            array.push(structureLevel, lvl)
            array.push(structureOriginBar, b1)
            array.push(structureBroken, false)
            array.push(structureBrokenBar, na)
            lnColor = dir == 1 ? color.new(color.lime, 0) : color.new(color.red, 0)
            line ln = line.new(b1, lvl, bar_index, lvl, extend=extend.right, color=color.new(lnColor, 30), style=line.style_dashed)
            array.push(structureLines, ln)
            label.new(b1, lvl, typ + " " + (dir == 1 ? "Bull" : "Bear"), style=label.style_label_left, color=color.new(lnColor, 60), textcolor=color.white, size=size.small)

if array.size(structureDir) > 0
    for i = 0 to array.size(structureDir) - 1
        if not array.get(structureBroken, i)
            dir = array.get(structureDir, i)
            lvl = array.get(structureLevel, i)
            brokenNow = dir == 1 ? (closeBreaks ? close > lvl : high > lvl) : (closeBreaks ? close < lvl : low < lvl)
            if brokenNow
                array.set(structureBroken, i, true)
                array.set(structureBrokenBar, i, bar_index)
                ln = array.get(structureLines, i)
                line.set_color(ln, dir == 1 ? color.lime : color.red)
                line.set_style(ln, line.style_solid)
                f_showLabel(bar_index, lvl, array.get(structureType, i) + " broken", dir == 1 ? color.lime : color.red)

// === Order Blocks ===
var box[] obBoxes = array.new_box()
var int[] obDir = array.new_int()
if showOrderBlocks and array.size(structureDir) > 0
    for i = 0 to array.size(structureDir) - 1
        if array.get(structureBroken, i) and array.get(structureBrokenBar, i) == bar_index
            dir = array.get(structureDir, i)
            int searchBars = 10
            int obIndex = na
            if dir == 1
                for j = 1 to searchBars
                    if close[j] < open[j]
                        obIndex := bar_index - j
                        break
            else
                for j = 1 to searchBars
                    if close[j] > open[j]
                        obIndex := bar_index - j
                        break
            if not na(obIndex)
                int offset = bar_index - obIndex
                candleOpen = open[offset]
                candleClose = close[offset]
                candleHigh = high[offset]
                candleLow = low[offset]
                top = dir == 1 ? math.max(candleOpen, candleClose) : candleHigh
                bottom = dir == 1 ? candleLow : math.min(candleOpen, candleClose)
                boxColor = dir == 1 ? color.new(color.green, 70) : color.new(color.orange, 70)
                bx = box.new(obIndex, top, bar_index, bottom, bgcolor=boxColor, border_color=color.new(color.white, 60), extend=extend.right)
                array.push(obBoxes, bx)
                array.push(obDir, dir)

if array.size(obBoxes) > 0
    for i = array.size(obBoxes) - 1 to 0
        bx = array.get(obBoxes, i)
        dir = array.get(obDir, i)
        mitigated = dir == 1 ? (closeBreaks ? close < box.get_bottom(bx) : low < box.get_bottom(bx)) : (closeBreaks ? close > box.get_top(bx) : high > box.get_top(bx))
        if mitigated
            box.set_border_color(bx, color.new(color.gray, 60))
            box.set_bgcolor(bx, color.new(color.gray, 80))

// === Liquidity (equal highs/lows within rangePercent) ===
var line[] liqLines = array.new_line()
if showLiquidity and array.size(swingLevels) >= 2
    int sz = array.size(swingLevels)
    int lastIdx = sz - 1
    float lastLevel = array.get(swingLevels, lastIdx)
    int lastType = array.get(swingTypes, lastIdx)
    float prevLevel = array.get(swingLevels, lastIdx - 1)
    int prevType = array.get(swingTypes, lastIdx - 1)
    if lastType == prevType and math.abs(lastLevel - prevLevel) / prevLevel <= rangePercent
        avgLevel = (lastLevel + prevLevel) / 2.0
        lineColor = lastType == 1 ? color.new(color.fuchsia, 40) : color.new(color.aqua, 40)
        ln = line.new(array.get(swingBars, lastIdx - 1), avgLevel, bar_index, avgLevel, extend=extend.right, color=lineColor, style=line.style_dotted)
        array.push(liqLines, ln)
        f_showLabel(array.get(swingBars, lastIdx), avgLevel, lastType == 1 ? "Liquidity Highs" : "Liquidity Lows", lineColor)
